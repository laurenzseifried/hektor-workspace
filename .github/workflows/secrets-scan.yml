name: Secrets Scan

on:
  pull_request:
    branches:
      - main
      - master
      - develop
  push:
    branches:
      - main
      - master
      - develop
  workflow_dispatch:

jobs:
  secrets-scan:
    runs-on: ubuntu-latest
    name: Scan for Secrets
    
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Full history for commit scanning
      
      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
      
      - name: Create Scan Script
        run: |
          cat > scan-secrets.js << 'SCRIPT'
          #!/usr/bin/env node
          /**
           * Secrets Scanning for CI/CD
           * Scans committed files and git history for secrets
           */
          
          const fs = require('fs');
          const path = require('path');
          const { execSync } = require('child_process');
          
          // Load patterns
          const patternsFile = '.secrets-patterns';
          let patterns = fs.readFileSync(patternsFile, 'utf-8')
            .split('\n')
            .filter(line => line && !line.startsWith('#'));
          
          // Whitelist functions
          function isWhitelisted(file) {
            // .env.example
            if (file.endsWith('.env.example')) return true;
            
            // Test/fixture files with markers
            if (file.includes('test') || file.includes('spec') || file.includes('fixtures')) {
              try {
                const content = fs.readFileSync(file, 'utf-8');
                if (/PLACEHOLDER|EXAMPLE|FAKE|TODO|FIXME|test.*token|dummy/i.test(content)) {
                  return true;
                }
              } catch (e) {}
            }
            
            // Docs with markers
            if (file.endsWith('.md') || file.endsWith('.txt') || file.includes('docs/')) {
              try {
                const content = fs.readFileSync(file, 'utf-8');
                if (/example|sample|placeholder|fake|do not use|never|not real/i.test(content)) {
                  return true;
                }
              } catch (e) {}
            }
            
            return false;
          }
          
          // Scan file
          function scanFile(file) {
            if (!fs.existsSync(file) || !fs.statSync(file).isFile()) return [];
            if (isWhitelisted(file)) return [];
            
            try {
              const content = fs.readFileSync(file, 'utf-8');
              const findings = [];
              const lines = content.split('\n');
              
              patterns.forEach(pattern => {
                const regex = new RegExp(pattern, 'gi');
                lines.forEach((line, idx) => {
                  // Skip if line has placeholder markers
                  if (/PLACEHOLDER|EXAMPLE|FAKE|dummy|test|YOUR_/i.test(line)) {
                    return;
                  }
                  
                  if (regex.test(line)) {
                    findings.push({
                      file,
                      line: idx + 1,
                      content: line.trim().substring(0, 80),
                      pattern
                    });
                  }
                });
              });
              
              return findings;
            } catch (e) {
              return [];
            }
          }
          
          // Get changed files (PR)
          function getChangedFiles() {
            try {
              const output = execSync('git diff --name-only --diff-filter=ACM origin/main...HEAD', {
                encoding: 'utf-8'
              });
              return output.split('\n').filter(f => f);
            } catch (e) {
              return [];
            }
          }
          
          // Scan git history
          function scanHistory(limit = 50) {
            try {
              const commits = execSync(`git log --oneline -${limit}`, { encoding: 'utf-8' })
                .split('\n')
                .filter(l => l)
                .map(l => l.split(' ')[0]);
              
              const findings = [];
              commits.forEach(commit => {
                try {
                  const files = execSync(`git diff-tree --no-commit-id --name-only -r ${commit}`, {
                    encoding: 'utf-8'
                  }).split('\n').filter(f => f);
                  
                  files.forEach(file => {
                    const content = execSync(`git show ${commit}:${file}`, { encoding: 'utf-8', stdio: ['pipe', 'pipe', 'ignore'] });
                    patterns.forEach(pattern => {
                      const regex = new RegExp(pattern, 'gi');
                      if (regex.test(content)) {
                        if (!/PLACEHOLDER|EXAMPLE|FAKE|dummy|test|YOUR_/i.test(content)) {
                          findings.push({
                            commit,
                            file,
                            pattern
                          });
                        }
                      }
                    });
                  });
                } catch (e) {}
              });
              
              return findings;
            } catch (e) {
              return [];
            }
          }
          
          // Main
          console.log('üîê Scanning for secrets in CI/CD...\n');
          
          // Scan changed files
          console.log('üìù Scanning changed files...');
          const changedFiles = getChangedFiles();
          let findings = [];
          
          changedFiles.forEach(file => {
            const fileFindings = scanFile(file);
            findings = findings.concat(fileFindings);
          });
          
          // Scan recent history
          console.log('üìú Scanning git history (last 50 commits)...');
          const historyFindings = scanHistory(50);
          
          // Report
          console.log('\n' + '='.repeat(60));
          
          if (findings.length === 0 && historyFindings.length === 0) {
            console.log('‚úÖ No secrets detected!');
            console.log('='.repeat(60));
            process.exit(0);
          }
          
          console.error('‚ùå SECRETS DETECTED\n');
          
          if (findings.length > 0) {
            console.error('CHANGED FILES:');
            findings.forEach(f => {
              console.error(`  ${f.file}:${f.line}: ${f.content}...`);
              console.error(`    Pattern: ${f.pattern}`);
            });
          }
          
          if (historyFindings.length > 0) {
            console.error('\nGIT HISTORY:');
            historyFindings.forEach(f => {
              console.error(`  ${f.commit} ${f.file}`);
              console.error(`    Pattern: ${f.pattern}`);
            });
          }
          
          console.error('\n' + '='.repeat(60));
          process.exit(1);
          SCRIPT
          
          chmod +x scan-secrets.js
      
      - name: Run Secrets Scan
        run: node scan-secrets.js
      
      - name: Comment on PR (if secrets found)
        if: failure()
        uses: actions/github-script@v7
        with:
          script: |
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: `‚ö†Ô∏è **Secrets Scan Failed**

This pull request contains patterns matching known secret formats. Please:

1. Remove any real secrets from the code
2. Use .env.example with placeholder values instead
3. Add sensitive files to .gitignore
4. Force-push the clean version

See the scan job output for details: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}`
            })
